# 操作系统

## 1.并发和并行

**相同点**

- CPU执行多个任务的方式
- 给人宏观的感受就是程序一起执行	

**不同点**

- 并发的多个任务之间是互相抢占资源的
- 并行的多个任务之间是不互相抢占资源的

### 并发

- 在操作系统中，一个时间段中有多个进程都处于已启动运行到运行完毕之间的状态。但任一个时刻点上仍只有一个进程在运行
- 并发的实质上是宏观并行，微观串行
- 并发通过进程调度算法实现的
- 虽然 CPU 在同一时刻只能执行一个任务，但是通过将 CPU 的使用权在恰当的时机分配给不同的任务，使得多个任务在视觉上看起来是一起执行的。
- CPU 的执行速度极快，多任务切换的时间也极短。
- 并发是针对单核单cpu提出的，多核单cpu也能实现并行					

### 并行

- 并行是针对多核cpu提出的概念
- 和单核 CPU 不同，多个CPU 真正实现了同时执行多个任务

### 2.并发与并行的技术支持

- 资源分配（cpu资源，内存资源，外部设备资源，磁盘资源）
- 资源的分配原则：
  - 提高资源利用率；
  - 在合理的时间内使用所有用户都可以得到所需资源（不要出现饿死的情况）——公平；
  - 对独占资源实施互斥使用；
  - 防止因资源分配不当而引起的死锁；这些目标相互牵制，需要权衡。

- 常用资源分配策略：
  - 进程调度算法
  - 内存管理
  - 设备管理
  - 文件管理

- 其他技术
  - 英特尔超线程技术
  - 虚拟cpu

## 2.同步与异步

- 同步和异步关注的是消息通信机制 (synchronous communication/ asynchronous communication)。
- 同步异步关注的是消息通信机制，而阻塞与非阻塞关注的是进程或者线程等待结果时的状态（继续等待就是阻塞，反之非阻塞）

### 同步

- 就是调用某个东西时，调用方得等待这个调用返回结果才能继续往后执行。

- 同步中强调的是程序执行的顺序

- 同步中一定存在阻塞状态

- 优点：

  - 易于控制
  - 时效性强，能够实时得到结果

- 缺点

  - 耦合度高（如果需要对代码进行修改，可能导致其他代码被迫更改）
  - 资源浪费（高并发情况下会造成资源浪费）
  - 级联失败（程序执行中一个环节出现错误，那么调用者都会出现错误）

  

###  异步

- 和同步相反 调用方不会理解得到结果，而是在调用发出后调用者可用继续执行后续操作，被调用者通过状体来通知调用者，或者通过回掉函数来处理这个调用
- 异步中可能存在阻塞状态，但是一定存在非阻塞状态
- 通知机制：
  - 信号（信号的实现方式：**(https://blog.csdn.net/q921374795/article/details/88840314)**）
  - 回调函数

+ 优点

  + 耦合度低

  + 提升了cpu的吞吐量

    

- 缺点

  - 难以控制

  - 使用不当会严重影响性能

    

##  3.阻塞与非阻塞

###  属性

- 在linux中，一些资源（管道文件，套接字文件，设备文件）默认是具有阻塞性质的，即在某一时刻，只能由一个进程或线程对资源进行读或者写（一些资源有读共享，写复制的特点）

  

### 概念

- 阻塞和非阻塞指的是程序等待返回**结果**时的状态

###  阻塞

- 程序有条件为满足时会陷入阻塞
- 操作系统会把被阻塞的进程加入到阻塞队列，阻塞队列会被操作系统调出内存（为了提高内存的利用率）
- 当阻塞的进程条件得到满足时加入就绪队列，会被调入内存等待执行，程序从就绪态到运行态涉及进程调度算法

### 非阻塞

- 可以手动改变一些资源的非阻塞属性（操作不当会出现比较严重的错误）
- 当程序条件不满足也不会等到条件满足

### 同步、异步、阻塞、非阻塞

- 同步阻塞： 如果小明点击下载按钮之后，就一直干瞪着进度条不做其他任何事情直到软件下载完成

- 异步阻塞（不常见）： 如果小明点击下载按钮之后，就一直干瞪着进度条不做其他任何事情直到软件下载完成，但是软件下载完成其实是会「叮」的一声通知的（但小明依然那样干等着）

- 同步非阻塞： 如果小明点击下载按钮之后，就去做其他事情了，不过他总需要时不时瞄一眼屏幕看软件是不是下载完成了

- 异步非阻塞： 如果小明点击下载按钮之后，就去做其他事情了，软件下载完之后「叮」的一声通知小明，小明再回来继续处理下载完的软件

  

## 4.缓冲区溢出及其危害

### 缓冲区

- 计算机程序一般都会使用到一些内存，这些内存或是程序内部使用，或是存放用户的输入数据，这样的内存一般称作缓冲区。

- 缓冲区就是一块连续的计算机内存区域，它可以保存相同数据类型的多个实例，如字符数组。

- 缓冲区溢出是指当计算机向缓冲区内填充数据位数时超过了缓冲区本身的容量，溢出的数据覆盖在合法数据上

  

### 常见缓冲区溢出

- 栈溢出

  - 递归函数没有函数出口
  - 没有保证足够的存储空间存储复制过来的字符串(strcpy, scanf)
  - 宽度溢出（将int类型的只赋值给char型）， 算数溢出（两个数相乘超过int范围）
  - 数组索引不在合法范围
  - 空字符错误（字符串没有\0结尾）

- 堆溢出

  - malloc申请100字节的空间，却访问了第101个字节(不一定会报错，程序也未必会终止，难以察觉的错误)

- BSS溢出

- 格式化串溢出

  

### 缓冲区溢出危害

- 缓冲区溢出攻击，可以导致程序运行失败、系统关机、重新启动，或者执行攻击者的指令，比如非法提升权限。
- 在当前网络与分布式系统安全中，被广泛利用的50%以上都是缓冲区溢出，其中最著名的例子是1988年利用fingerd漏洞的蠕虫。而缓冲区溢出中，最为危险的是堆栈溢出，因为入侵者可以利用堆栈溢出，在函数返回时改变返回程序的地址，让其跳转到任意地址，带来的危害一种是程序崩溃导致拒绝服务，另外一种就是跳转并且执行一段恶意代码，比如得到shell，然后为所欲为。

## 5.进程与线程

- 进程： 计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位
- 线程： 线程是执行运算的最小单位，是进程中的一个实体，是被系统独立调度和分派的基本单位
- 进程的优点：
  - 因为每个进程间独立分配资源，所以进程的独立性高，安全性高，稳定
  - 进程出现的错误比较容易定位，可再现性好
  - 通过增加CPU，就可以容易扩充性能
  - 可以尽量减少线程加锁/解锁的影响，极大提高性能，就算是线程运行的模块算法效率低也没关系

- 进程的缺点：
  - 多进程的并发性不如多线程，cpu的吞吐量不如多线程
  - 进程间的通信较为复杂，涉及内核态与用户态之间的转换影响性能
  - 创建进程与回收进程的系统开销大

- 线程的优点：
  - 提高并发性。通过线程可方便有效地实现并发性。进程可创建多个线程来执行同一程序的不同部分。
  - 开销少。创建或撤销线程比创建进程要快，所需开销很少。
  - 线程之间通信非常方便
  - 线程之间资源共享

- 线程的缺点
  - 线程之间的同步和加锁控制比较麻烦
  - 一个线程的崩溃可能影响到整个程序的稳定性
  - 到达一定的线程数程度后，即使再增加CPU也无法提高性能

### 进程与线程之间的区别

- 调度：线程作为处理器调度和分配的基本单位，而进程是作为拥有资源的基本单位

- 并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可以并发执行

- 拥有资源：进程是拥有资源的一个独立单位，有自己独立的地址空间；线程不拥有系统资源，但可以访问隶属于进程的资源，共享进程的地址空间.

- 系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。

  

###  进程与线程之间的关系

- 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。

- 资源分配给进程，同一进程的所有线程共享该进程的所有资源。

- 处理机分给线程，即真正在处理机上运行的是线程

- 线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。线程是指进程内的一个执行单元,也是进程内的可调度实体

  

### 为什么有进程还要有线程

- **进程**属于在CPU和系统资源等方面提供的抽象，能够有效提高CPU的利用率。

  **线程**是在进程这个层次上提供的一层并发的抽象

  - 能够使系统在同一时间能够做多件事情
  - 当进程遇到阻塞时，例如等待输入，线程能够使不依赖输入数据的工作继续执行
  - 可以有效地利用多处理器和多核计算机，在没有线程之前，多核并不能让一个进程的执行速度提高

- 资源：线程不需要操作系统为它分配资源，但是进程需要，分配的过程开销很大

- 切换效率：因为线程共享空间，线程之间的切换只需要栈帧偏移就能实现，但是进程需要调度算法等支持

- 通信机制：线程之间共享空间，通信只需要在共享的空间内就能进行通信，但是进程间地址空间独立，进行IPC可能涉及到用户态与内核态之间的转换，开销非常大

  

## 6. 进程间通信（IPC）

进程间通信的几种方式：

- 管道（pipe， 流数据）（两端，读端写端）

  - 匿名管道（只能用于关联进程间通信）（半双工通信）

    - 局限于单向通信 
    - 只能创建在它的进程以及其有亲缘关系的进程之间
    - 缓冲区有限

  - 命名管道（可以用于非关联进程间通信）（半双工通信）

    - 需要使用命令mkfifo pipename 创建一个命名管道，或者使用mkfifo函数创建一个管道文件

    - 非关联进程需要使用管道文件来创建一个命名管道

    - 可以实现任意进程间通信
    
    - 长期存于系统中，使用不当容易出错
    
    - 缓冲区有限
    
      

- 共享内存（mmap， 流数据）（最快）

  - 进程直接拷贝向共享内存中，不需要向内核中拷贝
  - mmap是DMA（直接内存访问）引擎实现的，没有cpu的参与
  - 读写数据时的拷贝次数少，
    - 传统通信方式：磁盘(DMA) --> 内核缓冲区 --> 用户缓冲区 -->内核缓冲区 --> 磁盘
    - mmap：磁盘(DMA) --> 用户缓冲区 --> 磁盘														
  - 优点：无须复制，快捷，信息量大
  - 缺点：
    - 通信是通过将共享空间缓冲区直接附加到进程的虚拟地址空间中来实现的，因此进程间的读写操作的同步问题
    - 利用内存缓冲区直接交换信息，内存的实体存在于计算机中，只能同一个计算机系统中的诸多进程共享，不方便网络通信

- 消息队列（报数据）：
  
  - posix消息队列
- system V消息队列
  - 优点：可以实现任意进程间的通信，并通过系统调用函数来实现消息发送和接收之间的同步，无需考虑同步问题，方便
  - 缺点：信息的复制需要额外消耗 CPU 的时间，不适宜于信息量大或操作频繁的场合
  
- 套接字

- 信号：一种比较复杂的通信方式，用于通知接收进程某个事件已经发生

- 磁盘文件（非常慢，没意义）

  

## 7. 进程调度算法

- **先来先服务调度算法(FCFS)**
  - **系统将按照作业到达的先后次序来进行调度**
  - **有利于长作业，但不利于短作业**
- **短作业优先调度算法(SJF)**
  - **SJF算法是以作业的长度来计算优先级，作业越短，其优先级越高。作业的长短是作业所要求的运行时间来衡量的**
  - 有利于短作业，不利于长作业
  - 缺点：
    - 必须知道作业的运行时间(只能程序员估计)
    - 不利于长作业，容易产生饥饿现象
    - 无法实现人机交互
    - 没有考虑到作业紧迫程度 
- **优先级调度算法(PSA)**
  - 优先级通常由外部指定，高优先级算法优先调入内存分配资源
  - 对于FCFS调度算法，等待时间越长，优先级越高
  - 对于SJF算法，运行时间越短，优先级越高
- **高相应比优先调度算法(HRRN)**



##  8. 分页和分段的区别

## 9. 抖动是什么

## 10.常见的内存的分配错误

## 11. 内存交换中，被换出的进程存在那里

## 12. 死锁

### 什么是死锁

- 死锁是一组相互竞争资源的线程因为他们之间得到互相等待导致“永久“阻塞的现象

  

### 死锁产生原因

- 系统资源不足
- 资源分配不当
- 进程运行推进顺序不当



### 死锁产生的四个必要条件

- 互斥

- 请求与保持

- 不可抢占

- 循环等待

  

### 解决死锁

- 预防死锁(针对死锁产生的必要条件)
  - 打破互斥条件：改造独占性资源为虚拟资源，大部分资源已无法改造。
  - 打破请求与保持条件： 在程序初期就分配该线程所需要的所有资源，缺少资源不能执行(资源浪费，容易产生饥饿现象)。优化：允许程序获得初期需要的资源就开始执行，在执行过程中在逐步释放不需要的资源
  - 打破不可抢占条件： 当一进程占有互斥资源后又申请互斥资源而无法满足，则释放原占有的资源。
  - 打破循环等待条件： 实现资源有序分配策略，对所有设备实现分类编号，所有进程只能采用按序号递增的形式申请资源。
- 避免死锁
  - 银行家算法
- 检测死锁
- 解除死锁
  - 优先将互斥资源分配给已经死锁的进程
  - 撤销进程









